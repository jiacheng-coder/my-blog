import{_ as s,o as a,c as e,U as n}from"./chunks/framework.a7041386.js";const f=JSON.parse('{"title":"React Hooks","description":"","frontmatter":{"tag":["React"]},"headers":[],"relativePath":"React/React Hooks.md","filePath":"React/React Hooks.md","lastUpdated":null}'),l={name:"React/React Hooks.md"},o=n(`<h1 id="react-hooks" tabindex="-1">React Hooks <a class="header-anchor" href="#react-hooks" aria-label="Permalink to &quot;React Hooks&quot;">​</a></h1><h2 id="一、产生原因" tabindex="-1">一、产生原因 <a class="header-anchor" href="#一、产生原因" aria-label="Permalink to &quot;一、产生原因&quot;">​</a></h2><p>React Hooks是React v16.8.0版本引入的新特性，它可以让我们在函数组件中使用state和其他React特性，从而避免使用类组件。</p><p>在使用React Hooks时，有一些注意事项和设计依据需要遵循。</p><h2 id="二、常用-hooks" tabindex="-1">二、常用 Hooks <a class="header-anchor" href="#二、常用-hooks" aria-label="Permalink to &quot;二、常用 Hooks&quot;">​</a></h2><h3 id="usestate-状态定义" tabindex="-1">useState：状态定义 <a class="header-anchor" href="#usestate-状态定义" aria-label="Permalink to &quot;useState：状态定义&quot;">​</a></h3><blockquote><p>不可变状态，只能通过创建状态时提供的方法，进行状态的修改，而不能直接对状态进行赋值</p></blockquote><ul><li>useState返回的第一个参数是当前state，第二个参数是更新state的函数。</li><li>在useState中如果需要更新state，不能基于当前的state进行更新，而是需要使用回调函数的方式进行更新，因为useState是异步更新state的。</li><li>不能在条件语句中使用useState，因为条件语句在每次渲染时都会执行，如果在条件语句中使用useState，会导致state的混乱。</li></ul><p>请记住：使用 useState 会触发组件的重新渲染。</p><p>例如：在一个组件中，引入了一个不需要改变的组件，同时使用useState定义并触发数据更改，则会造成这个被引入不必要的重渲染</p><h3 id="useeffect-副作用处理" tabindex="-1">useEffect：副作用处理 <a class="header-anchor" href="#useeffect-副作用处理" aria-label="Permalink to &quot;useEffect：副作用处理&quot;">​</a></h3><ul><li>useEffect是React Hooks中用于处理副作用的钩子函数。</li><li>useEffect会在组件渲染完成后执行，并在每次state或props发生变化时重新执行。</li><li>在useEffect中可以返回一个函数，这个函数会在组件被销毁时执行。</li></ul><h3 id="uselayouteffect-副作用处理" tabindex="-1">useLayoutEffect：副作用处理 <a class="header-anchor" href="#uselayouteffect-副作用处理" aria-label="Permalink to &quot;useLayoutEffect：副作用处理&quot;">​</a></h3><blockquote><p>useLayoutEffect是React提供的一个Hook函数，它和useEffect非常相似，都是用来处理副作用的，但是它们的执行时机不同。</p></blockquote><h4 id="useeffect-执行时机" tabindex="-1">useEffect 执行时机 <a class="header-anchor" href="#useeffect-执行时机" aria-label="Permalink to &quot;useEffect 执行时机&quot;">​</a></h4><p>useEffect 在内容重绘到页面之后 runs，useLayoutEffect在之前 runs</p><p>useEffect的执行时机是在<strong>DOM更新之后、浏览器绘制之后</strong>，也就是在useLayoutEffect之后执行。这个时机适合用来处理一些不需要立即执行的副作用，比如发送网络请求、修改全局状态等。</p><p>在组件首次渲染工作完成并将真实dom生成到页面以后，将对应的回调函数推入异步队列等待执行。</p><h4 id="uselayouteffect-执行时机" tabindex="-1">useLayoutEffect 执行时机 <a class="header-anchor" href="#uselayouteffect-执行时机" aria-label="Permalink to &quot;useLayoutEffect 执行时机&quot;">​</a></h4><p>useLayoutEffect的执行时机是在<strong>DOM更新之后、浏览器绘制之前</strong>，也就是在useEffect之前执行。这个时机非常适合用来读取DOM节点的尺寸、位置等信息，因为这些信息需要在浏览器绘制之前就要计算好，否则可能会导致页面闪烁等问题。</p><p>组件首次渲染工作完成并将真实dom生成到页面以后，将对应的回调函数推入同步队列等待执行，这意味着useLayouEffect会<strong>完全阻塞</strong>后续的更新工作，也就是说，组件首次渲染完成后，会立即执行useLayoutEffect的回调函数，而不用等待主线程中其他未完成的工作。</p><h4 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h4><p>useLayoutEffect的原理和useEffect类似，都是通过在组件渲染时注册副作用函数，然后在组件卸载时执行清除函数来实现的。不同的是，<strong>useLayoutEffect</strong>会在浏览器绘制之前执行副作用函数，因此它<strong>会阻塞浏览器的渲染过程</strong>，可能会导致性能问题。</p><p>简单的理解就是，useLayoutEffect是立即执行，useEffect是推入异步队列，最终执行时间不确定。</p><p>因此，<strong>一般情况下</strong>，我们应该<strong>优先</strong>使用useEffect，只有在需要读取DOM节点信息时才使用useLayoutEffect。</p><h3 id="usememo-计算属性" tabindex="-1">useMemo：计算属性 <a class="header-anchor" href="#usememo-计算属性" aria-label="Permalink to &quot;useMemo：计算属性&quot;">​</a></h3><h4 id="产生依据" tabindex="-1">产生依据 <a class="header-anchor" href="#产生依据" aria-label="Permalink to &quot;产生依据&quot;">​</a></h4><blockquote><p>可以使用useMemo实现useCallback</p></blockquote><p>useMemo类似于Vue3的计算属性，是针对于状态的，useCallback是针对函数的。。useCallback用来缓存函数，第一个参数是一个函数，但是他的这个函数不会被React执行，而是直接进入缓存；useMemo用来缓存状态，第一个参数也是一个函数，组件初始化时这个函数会被React直接执行，然后将其返回值进行缓存，第二个参数是依赖项，当依赖项变化时，React会重新执行对应的第一个参数，然后拿到最新的返回值，再次进行缓存。</p><h4 id="参数说明" tabindex="-1">参数说明 <a class="header-anchor" href="#参数说明" aria-label="Permalink to &quot;参数说明&quot;">​</a></h4><ul><li>useMemo接收两个参数，第一个参数是需要进行计算的函数，第二个参数是依赖项数组。</li><li>当依赖项数组中的值发生变化时，useMemo会重新执行计算函数，否则会使用上一次的计算结果。</li></ul><h3 id="usecallback-优化函数性能" tabindex="-1">useCallback：优化函数性能 <a class="header-anchor" href="#usecallback-优化函数性能" aria-label="Permalink to &quot;useCallback：优化函数性能&quot;">​</a></h3><h4 id="产生依据-1" tabindex="-1">产生依据 <a class="header-anchor" href="#产生依据-1" aria-label="Permalink to &quot;产生依据&quot;">​</a></h4><p>useCallback用于减少函数引用的创建次数。我们知道，每次组件的重新渲染都意味着内部所有的引用值都会被重新构建，每次函数组件的重新渲染都对应函数的重新执行。当不使用useCallback时，每一次状态变化，比如list或name状态变化，都会重新创建一个fetchData函数的引用，这是十分浪费性能的。实际上，fetchData函数只和url这个状态有关，当url这个状态不改变时，就不需要创建新的函数引用，因此就有了useCallback。</p><p>使用useCallback并且指定依赖项时，只有当url这个状态变化时，才会在新的时间切片里创建新的函数引用，否则就使用原先时间切片里的函数引用而无需创建新的引用。</p><h4 id="参数说明-1" tabindex="-1">参数说明 <a class="header-anchor" href="#参数说明-1" aria-label="Permalink to &quot;参数说明&quot;">​</a></h4><p>第一个参数是函数声明，第二个参数是依赖项，当依赖项发生了变动以后，对应的函数引用会被重新生成。若依赖项为空数组表示该回调函数不依赖于任何状态或属性，只会在组件挂载时创建一次，并在整个组件的生命周期内保持不变。这种情况下，useCallback的作用类似于普通的函数定义，但是由于它是在组件内部定义的，因此可以访问组件的状态和属性。使用空数组作为依赖项数组可以避免不必要的重新创建函数，从而提高性能。</p><h4 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h4><ul><li>useCallback接收两个参数，第一个参数是需要缓存的函数，第二个参数是依赖项数组。</li><li>当依赖项数组中的值发生变化时，useCallback会返回一个新的函数，否则会返回上一次缓存的函数。</li></ul><h3 id="useref-构建出脱离react控制的状态" tabindex="-1">useRef：构建出脱离React控制的状态 <a class="header-anchor" href="#useref-构建出脱离react控制的状态" aria-label="Permalink to &quot;useRef：构建出脱离React控制的状态&quot;">​</a></h3><h4 id="产生依据-2" tabindex="-1">产生依据 <a class="header-anchor" href="#产生依据-2" aria-label="Permalink to &quot;产生依据&quot;">​</a></h4><p>useState用于构建组件状态，当状态变更的时候组件必定重新渲染；useRef出现的目的是构建一个状态出来，但是这个状态是直接脱离React控制的，也不会造成重新渲染，同时状态还不会因为组件的重新渲染而被初始化。useRef完全脱离React控制，意味着更改refInstance.current的值，不会像修改useState定义的状态一样，造成页面的重新渲染。refInstance是可以直接读写的，不需要像useState一样使用给定的方法来修改。</p><h4 id="注意事项-1" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项-1" aria-label="Permalink to &quot;注意事项&quot;">​</a></h4><ul><li>useRef是React Hooks中用于获取DOM节点和存储任意值的钩子函数。</li><li>useRef返回的是一个对象，其中current属性是一个可变的变量，可以存储任意值。</li><li>在函数组件中，使用useRef可以获取DOM节点的引用。</li></ul><h3 id="usecontext-祖孙组件传值" tabindex="-1">useContext：祖孙组件传值 <a class="header-anchor" href="#usecontext-祖孙组件传值" aria-label="Permalink to &quot;useContext：祖孙组件传值&quot;">​</a></h3><h4 id="产生依据-3" tabindex="-1">产生依据 <a class="header-anchor" href="#产生依据-3" aria-label="Permalink to &quot;产生依据&quot;">​</a></h4><p>类似于Vue3的provide和inject，允许组件之间通过除 props 之外的方式共享数据，多用于<strong>祖孙组件</strong>之间的<strong>数据传递</strong>问题。</p><h4 id="核心实现" tabindex="-1">核心实现 <a class="header-anchor" href="#核心实现" aria-label="Permalink to &quot;核心实现&quot;">​</a></h4><ul><li>useContext是React Hooks中用于获取上下文的钩子函数。</li><li>使用useContext可以在函数组件中获取上下文的值，避免了使用类组件中的static contextType和Consumer。</li></ul><p>useContext 和 createContext 是 React 中用于跨组件传递数据的两个 API，通常用于全局数据管理。很多著名的库，例如 react-router, redux 都是基于 useContext 来做的；</p><p>createContext 用于创建一个上下文对象，useContext 用于在组件中获取上下文对象中的数据。</p><h4 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景&quot;">​</a></h4><p>当多个组件需要共享同一个数据时，可以使用 createContext 创建一个上下文对象，并将数据传递给上下文对象。然后在需要使用数据的组件中使用 useContext 获取上下文对象中的数据。</p><h4 id="注意事项-2" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项-2" aria-label="Permalink to &quot;注意事项&quot;">​</a></h4><ol><li>上下文对象中的数据应该是不可变的，避免直接修改上下文对象中的数据。</li><li>上下文对象中的数据应该是全局共享的，避免在组件中使用 useContext 获取到的数据与其他组件不一致。</li><li>上下文对象中的数据应该是简单的数据类型，避免在组件中使用 useContext 获取到的数据过于复杂。</li></ol><h3 id="usereducer-加强版-usestate" tabindex="-1">useReducer：加强版 useState <a class="header-anchor" href="#usereducer-加强版-usestate" aria-label="Permalink to &quot;useReducer：加强版 useState&quot;">​</a></h3><p>useReducer是React Hooks中用于管理组件状态的钩子函数。</p><ul><li>接收三个参数：第一个参数是<strong>reducer函数</strong>，第二个参数是<strong>初始状态</strong>，第三个参数是<strong>初始化行为函数</strong>。 <ul><li>第一个参数reducer函数接收两个参数，一个是state，一个是action（也就是dispatch函数的参数）</li><li>第二个参数通常是一个对象，作为初始值</li><li>第三个参数成为初始化行为，可以在此处做数据持久化的处理，详见代码示例</li></ul></li><li>返回值：useReducer返回的是一个包含state和dispatch函数的数组。此处的dispatch可以类比理解为 useState 的 setState，不过他比 useState 具有更多的功能</li></ul><p>下面是一个使用 useReducer 和 RooUI 实现的计数器功能，并实现了数据持久化：</p><div class="language-jsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Button</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">@roo/roo</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> initialState </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Conny</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">score</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">TAction</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">type</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">increment</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">decrement</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">payload</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">number</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> reducer </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">state</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">typeof</span><span style="color:#A6ACCD;"> initialState</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">action</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">TAction</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">switch</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">action</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">type</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">increment</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{...</span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> score</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">score</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">action</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">payload</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">decrement</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{...</span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> score</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">score</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">action</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">payload</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> initialAction </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">initState</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">typeof</span><span style="color:#A6ACCD;"> initialState</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">res</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">localStorage</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getItem</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">state</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">!!</span><span style="color:#A6ACCD;">res</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">JSON</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">parse</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">res</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">initState</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">TestUseReducer</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">dispatch</span><span style="color:#89DDFF;">]</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useReducer</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">reducer</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">initialState</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">initialAction</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">useEffect</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">localStorage</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setItem</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">state</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">JSON</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">stringify</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">state</span><span style="color:#F07178;">))</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">state</span><span style="color:#F07178;">])</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><h2 id="三、自定义-hooks" tabindex="-1">三、自定义 Hooks <a class="header-anchor" href="#三、自定义-hooks" aria-label="Permalink to &quot;三、自定义 Hooks&quot;">​</a></h2><p>常言道，能否书写好自定义 Hooks 是判断一个开发者是否是高级工程师的标准；在学会并理解上述常见 Hook 之后，可以将其用于业务场景中，从业务场景中抽离出可复用的逻辑，形成一套业务的 自定义 Hooks，是开发者的追求。</p><h3 id="usemousemove" tabindex="-1">useMouseMove <a class="header-anchor" href="#usemousemove" aria-label="Permalink to &quot;useMouseMove&quot;">​</a></h3><div class="language-jsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>\`import { useEffect, useState } from &#39;react&#39;;</p><p>function useMouseMove() { const [position, setPosition] = useState({ x: 0, y: 0 });</p><p>useEffect(() =&gt; { const handleMouseMove = (event:MouseEvent) =&gt; { setPosition({ x: event.clientX, y: event.clientY }); };</p><pre><code>document.addEventListener(&#39;mousemove&#39;, handleMouseMove);

return () =&gt; {
  document.removeEventListener(&#39;mousemove&#39;, handleMouseMove);
};
</code></pre><p>}, []);</p><p>return position; }</p><p>export default useMouseMove;\`</p><h3 id="usedownloadurl" tabindex="-1">useDownLoadUrl <a class="header-anchor" href="#usedownloadurl" aria-label="Permalink to &quot;useDownLoadUrl&quot;">​</a></h3><p>\`/**</p><ul><li>从后端的通用下载接口获取模版下载信息</li><li>@param type */ import { useCallback, useEffect, useState } from &#39;react&#39;; import { Toast } from &#39;@roo/roo&#39;; import { thfDownloadTemplate } from &#39;../services/api&#39;;</li></ul><p>const useDownLoadUrl = (type) =&gt; { const [templateUrl, setTemplateUrl] = useState(&#39;&#39;); const fetchDownTemplate = useCallback(async () =&gt; { try { const res: any = await thfDownloadTemplate({ type }); const { code, msg, data } = res; if (code === 0) { setTemplateUrl(data.url); } else { Toast.fail({ title: &#39;获取模版信息&#39; }); setTemplateUrl(&#39;&#39;); } } catch (e) { Toast.fail({ title: &#39;获取模版信息&#39; }); setTemplateUrl(&#39;&#39;); } }, [type]);</p><p>useEffect(() =&gt; { fetchDownTemplate(); }, []);</p><p>return { templateUrl }; }; export default useDownLoadUrl;\`</p><h2 id="四、不常见hook" tabindex="-1">四、不常见Hook <a class="header-anchor" href="#四、不常见hook" aria-label="Permalink to &quot;四、不常见Hook&quot;">​</a></h2><h3 id="useimperativehandle" tabindex="-1">useImperativeHandle <a class="header-anchor" href="#useimperativehandle" aria-label="Permalink to &quot;useImperativeHandle&quot;">​</a></h3><blockquote><p>参数</p></blockquote><ul><li>第一个参数是 ref</li><li>第二个参数是一个函数，这个函数的返回值最终被赋值给ref.current</li><li>第三个参数是依赖项，依赖项不变的话，ref.current不会被赋值</li></ul><h3 id="uselayouteffect" tabindex="-1">useLayoutEffect <a class="header-anchor" href="#uselayouteffect" aria-label="Permalink to &quot;useLayoutEffect&quot;">​</a></h3><blockquote><p>useEffect vs useLayoutEffect</p></blockquote><p>二者基本一致，只有运行机制不一样</p><p>大多业务都用 useEffect，很少用 useLayoutEffect</p><p>useEffect的运行规则：组件首次渲染工作完成并将真实dom生成到页面以后 将对应的回调函数推入异步队列等待执行</p><p>useLayoutEffect的运行规则：组件首次渲染工作完成并将真实dom生成到页面以后，将对应的回调函数推入同步队列等待执行【意味着useLayouEffect会完</p><p>全阻塞后续的更新工作，也就是说，组件首次渲染完成后，会立即执行useLayoutEffect的回调函数，而不用等待主线程中其他未完成的工作】</p><p>简单的理解就是，useLayoutEffect是立即执行，useEffect是推入异步队列，最终执行时间不确定</p><p>useLayoutEffect是React提供的一个Hook函数，它和useEffect非常相似，都是用来处理副作用的，但是它们的执行时机不同。</p><p>useLayoutEffect的执行时机是在DOM更新之后、浏览器绘制之前，也就是在useEffect之前执行。这个时机非常适合用来读取DOM节点的尺寸、位置等信息，因为这些信息需要在浏览器绘制之前就要计算好，否则可能会导致页面闪烁等问题。</p><p>useEffect的执行时机是在DOM更新之后、浏览器绘制之后，也就是在useLayoutEffect之后执行。这个时机适合用来处理一些不需要立即执行的副作用，比如发送网络请求、修改全局状态等。</p><p>useLayoutEffect的原理和useEffect类似，都是通过在组件渲染时注册副作用函数，然后在组件卸载时执行清除函数来实现的。不同的是，<strong>useLayoutEffect</strong>会在浏览器绘制之前执行副作用函数，因此它<strong>会阻塞浏览器的渲染过程</strong>，可能会导致性能问题。</p><p>因此，<strong>一般情况下</strong>，我们应该<strong>优先</strong>使用useEffect，只有在需要读取DOM节点信息时才使用useLayoutEffect。</p>`,94),t=[o];function p(r,c,i,u,y,D){return a(),e("div",null,t)}const h=s(l,[["render",p]]);export{f as __pageData,h as default};
