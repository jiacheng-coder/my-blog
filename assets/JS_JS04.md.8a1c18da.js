import{_ as s,o as a,c as n,U as l}from"./chunks/framework.a7041386.js";const C=JSON.parse('{"title":"Javascript进阶","description":"","frontmatter":{"tag":["JS"]},"headers":[],"relativePath":"JS/JS04.md","filePath":"JS/JS04.md","lastUpdated":1689602218000}'),o={name:"JS/JS04.md"},p=l(`<h1 id="javascript进阶" tabindex="-1">Javascript进阶 <a class="header-anchor" href="#javascript进阶" aria-label="Permalink to &quot;Javascript进阶&quot;">​</a></h1><h2 id="生成器函数和迭代器" tabindex="-1">生成器函数和迭代器 <a class="header-anchor" href="#生成器函数和迭代器" aria-label="Permalink to &quot;生成器函数和迭代器&quot;">​</a></h2><p>生成器函数和迭代器的作用和实现如下：</p><ul><li>生成器函数是ES6中新增的一种函数控制、使用的方案，它可以让我们更加灵活的控制函数什么时候继续执行、暂停执行等。生成器函数使用 function*语法编写。最初调用时，生成器函数不执行任何代码，而是返回一种称为 Generator 的迭代器³。</li><li>迭代器是使用户在容器对象（container，例如链表或数组）上可以遍历访问的对象，使用该接口无需关心容器对象的内部实现细节。迭代器协议定义了产生一系列值（无论是有限还是无限个）的标准方式，在JavaScript中这个标准就是一个特定的next方法。每次调用next方法，都会返回一个包含value和done属性的对象，其中value表示当前值，done表示是否结束²。</li><li>生成器函数和迭代器之间有紧密的联系，通过调用生成器的next方法，可以让生成器函数恢复执行，并在遇到yield关键字时暂停，并将yield后面的表达式作为当前值返回。当再次调用next方法时，生成器函数从上次暂停的地方继续执行，直到遇到return或者抛出异常或者没有更多代码可执行为止³。</li><li>以下是一个简单的生成器函数和迭代器的例子：</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 定义一个生成器函数</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">gen</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 使用yield关键字来暂停并返回当前值</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">yield</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">hello</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">yield</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">world</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">end</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 调用生成器函数得到一个迭代器</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> iterator </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">gen</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 调用迭代器的next方法</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(iterator</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">next</span><span style="color:#A6ACCD;">())</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// {value: &quot;hello&quot;, done: false}</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(iterator</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">next</span><span style="color:#A6ACCD;">())</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// {value: &quot;world&quot;, done: false}</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(iterator</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">next</span><span style="color:#A6ACCD;">())</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// {value: &quot;end&quot;, done: true}</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(iterator</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">next</span><span style="color:#A6ACCD;">())</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// {value: undefined, done: true}</span></span></code></pre></div><h2 id="元编程🔥" tabindex="-1">元编程🔥 <a class="header-anchor" href="#元编程🔥" aria-label="Permalink to &quot;元编程🔥&quot;">​</a></h2><blockquote><p>元编程是指使用代码来操作或生成其他代码的技术。在JavaScript中，元编程可以通过使用Proxy和Reflect对象来实现，它们可以拦截和修改对象的基本操作 。</p></blockquote><p>元编程的例子有很多，不同的语言和场景可能有不同的实现方式。在JavaScript中，一个简单的元编程的例子是使用Proxy对象来拦截和修改对象的属性访问²。例如，下面的代码创建了一个Proxy对象，它可以在访问对象的属性时自动添加前缀：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Alice</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">age</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">20</span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> proxy </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Proxy</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">get</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">target</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">prop</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Hello </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">target</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">prop</span><span style="color:#F07178;">]</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(proxy</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// Hello Alice</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(proxy</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">age)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// Hello 20</span></span></code></pre></div><p>元编程在js里的应用场景也有很多，主要可以利用Proxy和Reflect对象来拦截和定义基本语言操作的自定义行为，例如属性查找、赋值、枚举、函数调用等¹。例如，你可以使用Proxy对象来实现一个虚拟DOM，它可以在访问真实DOM时进行一些优化和处理²。你也可以使用Reflect对象来实现一个动态代理，它可以在调用目标对象的方法时进行一些拦截和增强³。</p><h2 id="虚拟dom" tabindex="-1">虚拟DOM <a class="header-anchor" href="#虚拟dom" aria-label="Permalink to &quot;虚拟DOM&quot;">​</a></h2><p>虚拟DOM的例子有很多，比如React、Vue等前端框架都使用了虚拟DOM的技术。虚拟DOM是一个JS对象，它可以描述一个DOM节点的标签、属性和子节点。虚拟DOM可以通过render函数转化为真实的DOM，并插入到页面中。虚拟DOM还可以给任何其他实体建立映射关系，比如iOS应用、安卓应用、小程序等</p><p>虚拟DOM和真实DOM的区别主要有以下几点:</p><ul><li>真实DOM是浏览器提供的操作HTML的接口，它是一个结构化文本的抽象，可以通过JS来修改网页的内容和样式。</li><li>虚拟DOM是一个普通的JS对象，它是一个用来描述真实DOM结构的对象，包含了标签、属性和子节点等信息。</li><li>真实DOM操作很慢，因为每次修改都会引起浏览器的重绘和回流，消耗性能和内存。</li><li>虚拟DOM操作很快，因为它只是在内存中进行计算，不会直接影响真实DOM。</li><li>虚拟DOM可以通过render函数转化为真实DOM，并插入到页面中。虚拟DOM还可以通过diff算法比较两个虚拟DOM树的差异，并只更新变化的部分到真实DOM上。这样可以提高渲染效率和用户体验。</li></ul>`,14),e=[p];function t(c,r,D,y,F,i){return a(),n("div",null,e)}const d=s(o,[["render",t]]);export{C as __pageData,d as default};
