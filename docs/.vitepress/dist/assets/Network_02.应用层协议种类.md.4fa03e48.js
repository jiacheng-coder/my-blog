import{_ as t,o,c as e,U as a}from"./chunks/framework.876add27.js";const r="/assets/image-20230314123453949.8509ad65.png",s="/assets/image-20230314122454058.e127e08f.png",l="/assets/image-20230314122845393.c735bca9.png",n="/assets/image-20230314124435366.6c784fb2.png",i="/assets/image-20230314124759796.cbdd4e24.png",p="/assets/image-20230307122650848.519aced0.png",q=JSON.parse('{"title":"应用层-协议种类","description":"","frontmatter":{"tag":["计算机网络"]},"headers":[],"relativePath":"Network/02.应用层协议种类.md","filePath":"Network/02.应用层协议种类.md","lastUpdated":1689602218000}'),c={name:"Network/02.应用层协议种类.md"},g=a('<h1 id="应用层-协议种类" tabindex="-1">应用层-协议种类 <a class="header-anchor" href="#应用层-协议种类" aria-label="Permalink to &quot;应用层-协议种类&quot;">​</a></h1><p><strong>应用层有许多协议，包括</strong></p><ol><li><strong>域名系统DNS协议</strong></li><li><strong>FTP文件传输协议</strong></li><li>Telnet远程终端协议</li><li>Telnet远程登录协议</li><li><strong>SMTP电子邮件协议</strong></li><li><strong>POP3邮件读取协议</strong></li><li>SNMP简单网络管理协议等</li><li><strong>HTTP超文本传输协议</strong></li></ol><blockquote><p>应用层协议 (application layer protocol)定义了运行在不同端系统上的应用程序进程</p><p>相互传递报文的方式</p></blockquote><h2 id="dns" tabindex="-1">DNS <a class="header-anchor" href="#dns" aria-label="Permalink to &quot;DNS&quot;">​</a></h2><h2 id="ftp" tabindex="-1">FTP <a class="header-anchor" href="#ftp" aria-label="Permalink to &quot;FTP&quot;">​</a></h2><h2 id="smtp与pop3" tabindex="-1">SMTP与POP3 <a class="header-anchor" href="#smtp与pop3" aria-label="Permalink to &quot;SMTP与POP3&quot;">​</a></h2><h3 id="邮件的发送与读取流程" tabindex="-1">邮件的发送与读取流程 <a class="header-anchor" href="#邮件的发送与读取流程" aria-label="Permalink to &quot;邮件的发送与读取流程&quot;">​</a></h3><p>电子邮件系统采用客户/服务器（C/S）方式。 电子邮件系统的三个主要组成构件：用户代理，邮件服务器，以及电子邮件所需的协议。</p><ul><li><p>用户代理是用户与电子邮件系统的接口，又称为<strong>电子邮件客户端软件</strong>。</p></li><li><p>邮件服务器是电子邮件系统的基础设施。因特网上所有的ISP都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱。</p></li><li><p>协议包括邮件发送协议（例如SMTP）和邮件读取协议（例如POP3, IMAP)</p></li></ul><p><img src="'+r+'" alt="image-20230314123453949"></p><p>邮件的发送要经历两个流程</p><ul><li>用户代理到发送方邮件服务器</li><li>发送方邮件服务器到接受方邮件服务器</li></ul><p>邮件的接收要经历一个流程</p><ul><li>接收方邮件服务器到接受方用户代理</li></ul><h3 id="smtp原理" tabindex="-1">SMTP原理 <a class="header-anchor" href="#smtp原理" aria-label="Permalink to &quot;SMTP原理&quot;">​</a></h3><p><img src="'+s+'" alt="image-20230314122454058"></p><p>注意：</p><ol><li><p>为了简单起见，省略了认证过程；</p></li><li><p>应答代码后面一般都跟有简单的描述信息</p></li><li><p>不同的SMTP服务器给出的相同应答代码 的描述信息可能不同</p></li></ol><h3 id="邮件格式" tabindex="-1">邮件格式 <a class="header-anchor" href="#邮件格式" aria-label="Permalink to &quot;邮件格式&quot;">​</a></h3><p>电子邮件的信息格式并不是由SMTP定义的，而是在RFC 822中单独定义的。这个RFC文档己在2008年更新为RFC 5322。一个电子邮件有信封和内容两部分。而内容又由首部和主体两部分构成。</p><p><img src="'+l+'" alt="image-20230314122845393"></p><h3 id="smtp的缺陷与mime的产生" tabindex="-1">SMTP的缺陷与MIME的产生 <a class="header-anchor" href="#smtp的缺陷与mime的产生" aria-label="Permalink to &quot;SMTP的缺陷与MIME的产生&quot;">​</a></h3><ul><li><p>SMTP协议只能传送ASCI码文本数据，不能传送可执行文件或其他的二进制对象。</p></li><li><p>SMTP协议只能传送7位(7比特)的ASCII码</p></li><li><p>SMTP不能满足传送多媒体邮件（例如带有图片、音频或视频数据）的需要。并且许多其他非英语国家的文字 (例如中文、俄文、甚至带有重音符号的法文或德文）也无法用SMTP传送。</p></li><li><p>为解决SMTP传送非ASCII码文本的问题，提出了多用途因特网邮件扩展MIME (Multipurpose Internet Mail Extensions)</p><ul><li><p>增加了5个新的邮件首部字段，这些字段提供了有关邮件主体的信息。</p></li><li><p>定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标淮化。 口</p></li><li><p>定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。</p></li><li><blockquote><p>实际上，MIME不仅仅用于SMTP，也用于后来的同样面向ASCl字符的HTTP。</p></blockquote></li></ul></li></ul><h3 id="邮件的读取" tabindex="-1">邮件的读取 <a class="header-anchor" href="#邮件的读取" aria-label="Permalink to &quot;邮件的读取&quot;">​</a></h3><p>常用的邮件读取协议有以下两个：</p><ul><li>邮局协议POP (Post Office Protocol)，POP3是其第三个版本，是因特网正式标准。 非常简单、功能有限的邮件读取协议。用户只能以下载并删除方式或下载并保留方式从邮件服务器下载邮件到用户方计算机。不允许用户在邮件服务器上管理自己的邮件。（例如创建文件夹，对邮件进行分类管理等)。</li><li>因特网邮件访问协议IMAP (Internet Message Access Protocol)，IMAP4是其第四个版本，目前还只是因特网建议标准。功能比POP3强大的邮件读取协议。用户在自己的计算机上就可以操控邮件服务器中的邮箱，就像在本地操控一样，因此IMAP是一个联机协议。</li><li>POP3和IMAP4都采用基于TCP连接的客户/服务器方式。POP3使用熟知端口110，IMAP4使用熟 知端口143。</li></ul><h3 id="基于http的邮件发送" tabindex="-1">基于HTTP的邮件发送 <a class="header-anchor" href="#基于http的邮件发送" aria-label="Permalink to &quot;基于HTTP的邮件发送&quot;">​</a></h3><ul><li><p>通过浏览器登录（提供用户名和口令）邮件服务器万维网网站就可以撰写、收发、阅读和管理电子邮件。</p></li><li><p>这种工作模式与IMAP很类似，不同的是用户计算机无需安装专门的用户代理程序，只需要 使用通用的万维网浏览器。</p></li><li><p>邮件服务器网站通常都提供非常强大和方便的邮件管理功能，用户可以在邮件服务器网站上管理和处理自己的邮件，而不需要将邮件下载到本地进行管理。</p><p><img src="'+n+'" alt="image-20230314124435366"></p></li></ul><h3 id="习题" tabindex="-1">习题 <a class="header-anchor" href="#习题" aria-label="Permalink to &quot;习题&quot;">​</a></h3><p><img src="'+i+'" alt="image-20230314124759796"></p><h2 id="websocket的产生" tabindex="-1">WebSocket的产生 <a class="header-anchor" href="#websocket的产生" aria-label="Permalink to &quot;WebSocket的产生&quot;">​</a></h2><h3 id="http-不断轮询" tabindex="-1">HTTP 不断轮询 <a class="header-anchor" href="#http-不断轮询" aria-label="Permalink to &quot;HTTP 不断轮询&quot;">​</a></h3><p>问题的痛点在于，<strong>怎么样才能在用户不做任何操作的情况下，网页能收到消息并发生变更。</strong></p><p>最常见的解决方案是，<strong>网页的前端代码里不断定时发 HTTP 请求到服务器，服务器收到请求后给客户端响应消息。</strong></p><p>这其实时一种「<strong>伪</strong>」服务器推的形式。</p><p>它其实并不是服务器主动发消息到客户端，而是客户端自己不断偷偷请求服务器，只是用户无感知而已。</p><p>以「扫码登录」的场景为例:</p><p>某信公众号平台，登录页面二维码出现之后，<strong>前端</strong>网页根本不知道用户扫没扫，于是不断去向<strong>后端</strong>服务器询问，看有没有人扫过这个码。而且是以大概 1 到 2 秒的间隔去不断发出请求，这样可以保证用户在扫码后能在 1 到 2 秒内得到及时的反馈，不至于<strong>等太久</strong>。</p><p>使用HTTP定时轮询</p><p>但这样，会有两个比较明显的问题：</p><ul><li>当你打开 F12 页面时，你会发现满屏的 HTTP 请求。虽然很小，但这其实也消耗带宽，同时也会增加下游服务器的负担。</li><li>最坏情况下，用户在扫码后，需要等个 1~2 秒，正好才触发下一次 HTTP 请求，然后才跳转页面，用户会感到<strong>明显的卡顿</strong>。</li></ul><p>使用起来的体验就是，二维码出现后，手机扫一扫，然后在手机上点个确认，这时候<strong>卡顿等个 1~2 秒</strong>，页面才跳转。</p><blockquote><p>使用长轮询可以解决这个问题</p></blockquote><h3 id="http-长轮询" tabindex="-1">HTTP 长轮询 <a class="header-anchor" href="#http-长轮询" aria-label="Permalink to &quot;HTTP 长轮询&quot;">​</a></h3><p>我们知道，HTTP 请求发出后，一般会给服务器留一定的时间做响应，比如 3 秒，规定时间内没返回，就认为是超时。</p><p>如果我们的 HTTP 请求<strong>将超时设置的很大</strong>，比如 30 秒，<strong>在这 30 秒内只要服务器收到了扫码请求，就立马返回给客户端网页。如果超时，那就立马发起下一次请求。</strong></p><p>这样就减少了 HTTP 请求的个数，并且由于大部分情况下，用户都会在某个 30 秒的区间内做扫码操作，所以响应也是及时的。</p><p><img src="'+p+'" alt="image-20230307122650848"></p><p>比如，某度云网盘就是这么干的。所以你会发现一扫码，手机上点个确认，电脑端网页就<strong>秒跳转</strong>，体验很好。</p><blockquote><p>像这种发起一个请求，在较长时间内等待服务器响应的机制，就是所谓的<strong>长训轮机制</strong>。我们常用的消息队列 RocketMQ 中，消费者去取数据时，也用到了这种方式。</p></blockquote><p><strong>复杂场景下:</strong></p><p>上面提到的两种解决方案（不断轮询和长轮询），本质上，其实还是客户端主动去取数据。</p><p>对于像扫码登录这样的<strong>简单场景</strong>还能用用。但如果是网页游戏呢，游戏一般会有大量的数据需要从服务器主动推送到客户端。</p><p>这就得说下 <strong>WebSocket</strong> 了。</p><h3 id="websocket是什么" tabindex="-1">WebSocket是什么 <a class="header-anchor" href="#websocket是什么" aria-label="Permalink to &quot;WebSocket是什么&quot;">​</a></h3><blockquote><p>WebSocket是应用层协议, 是为了解决HTTP/1.1半双工的缺陷</p></blockquote><p>我们知道 TCP 连接的两端，<strong>同一时间里</strong>，<strong>双方</strong>都可以<strong>主动</strong>向对方发送数据。这就是所谓的<strong>全双工</strong>。</p><p>而现在使用最广泛的<code>HTTP/1.1</code>，也是基于TCP协议的，<strong>同一时间里</strong>，客户端和服务器<strong>只能有一方主动</strong>发数据，这就是所谓的<strong>半双工</strong>。</p><p>也就是说，好好的全双工 TCP，被 HTTP/1.1 用成了半双工。</p><p>这是由于 HTTP 协议设计之初，考虑的是看看网页文本的场景，能做到<strong>客户端发起请求再由服务器响应</strong>，就够了，根本就没考虑网页游戏这种，客户端和服务器之间都要互相主动发大量数据的场景。</p><p>所以，为了更好的支持这样的场景，我们需要另外一个<strong>基于TCP的新协议</strong>。</p><p>于是新的应用层协议<strong>WebSocket</strong>就被设计出来了。注意:socket和Web Socket毫无关系</p><h3 id="http和websocket的关系" tabindex="-1">HTTP和WebSocket的关系 <a class="header-anchor" href="#http和websocket的关系" aria-label="Permalink to &quot;HTTP和WebSocket的关系&quot;">​</a></h3><p>WebSocket和HTTP一样都是基于TCP的协议。<strong>经历了三次TCP握手之后，利用 HTTP 协议升级为 WebSocket 协议</strong>。</p><p>你在网上可能会看到一种说法：&quot;WebSocket 是基于HTTP的新协议&quot;，<strong>其实这并不对</strong>，因为WebSocket只有在建立连接时才用到了HTTP，<strong>升级完成之后就跟HTTP没有任何关系了</strong>。</p><h3 id="websocket消息格式" tabindex="-1">WebSocket消息格式 <a class="header-anchor" href="#websocket消息格式" aria-label="Permalink to &quot;WebSocket消息格式&quot;">​</a></h3><p>WebSocket的数据格式也是<strong>数据头（内含payload长度） + payload data</strong> 的形式。</p><p>这是因为 TCP 协议本身就是全双工，但直接使用<strong>纯裸TCP</strong>去传输数据，会有<strong>粘包</strong>的&quot;问题&quot;。为了解决这个问题，上层协议一般会用<strong>消息头+消息体</strong>的格式去重新包装要发的数据。</p><p>而<strong>消息头</strong>里一般含有<strong>消息体的长度</strong>，通过这个长度可以去截取真正的消息体。</p><p>HTTP 协议和大部分 RPC 协议，以及我们今天介绍的WebSocket协议，都是这样设计的。</p><h3 id="websocket的使用场景" tabindex="-1">WebSocket的使用场景 <a class="header-anchor" href="#websocket的使用场景" aria-label="Permalink to &quot;WebSocket的使用场景&quot;">​</a></h3><p>WebSocket完美继承了 TCP 协议的<strong>全双工</strong>能力，并且还贴心的提供了解决粘包的方案。</p><p>它适用于<strong>需要服务器和客户端（浏览器）频繁交互</strong>的大部分场景，比如网页/小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。</p><p>回到文章开头的问题，在使用 WebSocket 协议的网页游戏里，怪物移动以及攻击玩家的行为是<strong>服务器逻辑</strong>产生的，对玩家产生的伤害等数据，都需要由<strong>服务器主动发送给客户端</strong>，客户端获得数据后展示对应的效果。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/31410d2e885aab55c2c588aad754bb5c.png" alt="图片"></p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><ul><li>TCP 协议本身是<strong>全双工</strong>的，但我们最常用的 HTTP/1.1，虽然是基于 TCP 的协议，但它是<strong>半双工</strong>的，对于大部分需要<strong>服务器主动推送数据到客户端</strong>的场景，都不太友好，因此我们需要使用<strong>支持全双工</strong>的 WebSocket 协议。</li><li>在 HTTP/1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用<strong>定时轮询或者长轮询</strong>的方式实现<strong>服务器推送</strong>(comet)的效果。</li><li>对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。</li><li>WebSocket 和 socket 几乎没有任何关系，只是叫法相似。</li><li>正因为各个浏览器都支持 HTTP协 议，所以 WebSocket 会先利用HTTP协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 WebSocket 的数据格式进行收发数据。</li></ul><h2 id="http" tabindex="-1">HTTP <a class="header-anchor" href="#http" aria-label="Permalink to &quot;HTTP&quot;">​</a></h2><blockquote><p>详见后文...</p></blockquote>',80),P=[g];function h(T,b,d,u,k,m){return o(),e("div",null,P)}const _=t(c,[["render",h]]);export{q as __pageData,_ as default};
