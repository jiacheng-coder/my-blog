import{_ as a,o as e,c as l,U as s}from"./chunks/framework.a7041386.js";const _=JSON.parse('{"title":"框架抽象","description":"","frontmatter":{"tag":["React"]},"headers":[],"relativePath":"React/框架抽象.md","filePath":"React/框架抽象.md","lastUpdated":null}'),n={name:"React/框架抽象.md"},t=s(`<h1 id="框架抽象" tabindex="-1">框架抽象 <a class="header-anchor" href="#框架抽象" aria-label="Permalink to &quot;框架抽象&quot;">​</a></h1><p>层级划分（三层）：</p><ul><li>应用层面 <ul><li>组件层面 <ul><li>节点层面</li></ul></li></ul></li></ul><h3 id="工作原理" tabindex="-1"><strong>工作原理</strong> <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;**工作原理**&quot;">​</a></h3><blockquote><p>UI = f(state)</p></blockquote><p>视图 = 框架内部运行机制(状态)</p><p>框架内部的运行机制根据状态渲染视图</p><h3 id="不同框架的区别" tabindex="-1"><strong>不同框架的区别</strong> <a class="header-anchor" href="#不同框架的区别" aria-label="Permalink to &quot;**不同框架的区别**&quot;">​</a></h3><blockquote><p>不同框架的区别主要是更新粒度的区别</p></blockquote><h3 id="_1-节点级更新粒度-svelte" tabindex="-1"><strong>1. 节点级更新粒度 - Svelte</strong> <a class="header-anchor" href="#_1-节点级更新粒度-svelte" aria-label="Permalink to &quot;**1. 节点级更新粒度 - Svelte**&quot;">​</a></h3><blockquote><p>关键词: 预编译 细粒度更新</p></blockquote><p>原理:</p><ol><li>将状态变化可能导致的节点变化编译为具体方法</li><li>监听状态变化</li><li>当交互导致状态变化后直接调用具体方法, 改变对应视图</li></ol><p>例子:</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">&lt;h1 on:click={handleClick}&gt;{}count&lt;/h1&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ol><li><p>将cout状态变化可能导致h1内的文本节点变化, 编译为update方法, 即:预编译过程</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 每次调用update方法, 如果count状态变化, 就更新视图中对应的文本节点</span></span>
<span class="line"><span style="color:#A6ACCD;"> function update(ctx, [dirty]) {</span></span>
<span class="line"><span style="color:#A6ACCD;">   if (dirty &amp; /*count*/ 1) {</span></span>
<span class="line"><span style="color:#A6ACCD;">     set_data_dev(t0, /*count*/ ctx[0]);</span></span>
<span class="line"><span style="color:#A6ACCD;">   }</span></span>
<span class="line"><span style="color:#A6ACCD;"> }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li><li><p>监听状态变化, 采用&quot;发布订阅&quot;的设计模式, 通过这种方式, 框架能对每个状态变化作出反应, 即实现细粒度更新</p><ol><li>订阅: 每当创建一个状态后, 会为该状态维护一个订阅该状态变化的表, 所有需要监听该状态变化的回调函数都会在该表中注册</li><li>发布: 每当状态变化, 会遍历这个表, 将&quot;状态变了&quot;这一消息发布出去, 每个订阅该状态的回调函数都会接受到通知并执行</li></ol></li></ol><blockquote><p>代表: Svelte, Solid.js</p></blockquote><h3 id="_2-应用级更新框架-react" tabindex="-1"><strong>2. 应用级更新框架 - React</strong> <a class="header-anchor" href="#_2-应用级更新框架-react" aria-label="Permalink to &quot;**2. 应用级更新框架 - React**&quot;">​</a></h3><blockquote><p>关键词: 虚拟DOM</p></blockquote><p>节点级框架需要监听状态的变化, 应用级框架则不关心状态的变化, 因为应用级框架中, 任何一个状态变化, 都会创建一颗完整的虚拟DOM树, 框架会通过前后虚拟DOM的对比找到变化的部分, 最终将变化的状态更新到视图</p><ol><li>状态变化</li><li>创建一棵<strong>完整</strong>的虚拟DOM树</li><li>比较, 并将变化的部分更新到视图</li></ol><h3 id="_3-组件级更新框架-vue" tabindex="-1"><strong>3. 组件级更新框架 - Vue</strong> <a class="header-anchor" href="#_3-组件级更新框架-vue" aria-label="Permalink to &quot;**3. 组件级更新框架 - Vue**&quot;">​</a></h3><blockquote><p>关键词:</p><p>Vue2 虚拟DOM+细粒度更新</p><p>Vue3 虚拟DOM+预编译+细粒度更新</p></blockquote><ol><li>状态变化</li><li>针对组件层面, 创建一棵<strong>组件级</strong>虚拟DOM树</li><li>比较, 并将变化的部分更新到视图</li></ol>`,24),o=[t];function i(p,r,c,u,d,h){return e(),l("div",null,o)}const m=a(n,[["render",i]]);export{_ as __pageData,m as default};
