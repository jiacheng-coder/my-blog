import{_ as t,o as a,c as e,U as i}from"./chunks/framework.876add27.js";const l="/assets/image-20230327233745045.86f38005.png",r="/assets/image-20230327234300572.07e2df07.png",b=JSON.parse('{"title":"","description":"","frontmatter":{"tag":["计算机网络"]},"headers":[],"relativePath":"Network/06.计网快问快答.md","filePath":"Network/06.计网快问快答.md","lastUpdated":1689602218000}'),o={name:"Network/06.计网快问快答.md"},d=i('<h2 id="网络体系" tabindex="-1">网络体系 <a class="header-anchor" href="#网络体系" aria-label="Permalink to &quot;网络体系&quot;">​</a></h2><p><img src="https://pic1.zhimg.com/v2-dc8ac903cd28c9e5b158c1d16677c810_r.jpg" alt="img"></p><p>实际使用的是应用层，传输层，网络层和网络接口层</p><p>在五层协议中，是把TCP/IP的网络接口层重新划分为了物理层和数据链路层</p><p>在OSI七层协议中，是把TCP/IP的应用层划分为了会话层，表示层和应用层</p><h3 id="osi七层" tabindex="-1">OSI七层 <a class="header-anchor" href="#osi七层" aria-label="Permalink to &quot;OSI七层&quot;">​</a></h3><p><img src="https://pic2.zhimg.com/v2-bd9524fab91608122dc1f44633ba080d_r.jpg" alt="img"></p><h2 id="应用层" tabindex="-1">应用层 <a class="header-anchor" href="#应用层" aria-label="Permalink to &quot;应用层&quot;">​</a></h2><h3 id="状态码" tabindex="-1">状态码 <a class="header-anchor" href="#状态码" aria-label="Permalink to &quot;状态码&quot;">​</a></h3><p><a href="https://http.devtool.tech/" target="_blank" rel="noreferrer">https://http.devtool.tech/</a> 「强烈推荐：状态码速查」</p><h2 id="传输层" tabindex="-1">传输层 <a class="header-anchor" href="#传输层" aria-label="Permalink to &quot;传输层&quot;">​</a></h2><p>传输层主要作用：建立端到端的连接，比如我们的客户端到服务端就是端到端</p><h3 id="tcp为什么要三次握手" tabindex="-1">TCP为什么要三次握手？ <a class="header-anchor" href="#tcp为什么要三次握手" aria-label="Permalink to &quot;TCP为什么要三次握手？&quot;">​</a></h3><ul><li>面向连接</li><li>可靠</li><li>面向字节流</li><li>全双工</li></ul><p>首先，明确三次握手的过程</p><p><img src="'+l+'" alt="image-20230327233745045"></p><p>三次握手是为了防止已经失效的请求报文，突然又传到服务器引起错误，防止由于网络滞留重发SYN包的情况</p><p>本质来说，三次握手是为了解决网络信道不可靠的问题，为了在不可靠的信道上，建立起可靠的连接</p><h3 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h3><p><img src="'+r+'" alt="image-20230327234300572"></p><p>保证对方已收到ACK 包，假设客户端送完最后一包 ACK包后就释放了连接，一旦ACK包在网络中丢失，服务端将一直停留在最后确认状态</p><p>为了在不可靠的信道上，建立起可靠的连接断开确认</p><h2 id="网络层" tabindex="-1">网络层 <a class="header-anchor" href="#网络层" aria-label="Permalink to &quot;网络层&quot;">​</a></h2><h2 id="网络接口层" tabindex="-1">网络接口层 <a class="header-anchor" href="#网络接口层" aria-label="Permalink to &quot;网络接口层&quot;">​</a></h2><ul><li>arp协议： <ul><li>ARP广播报文，询问设备的mac地址</li></ul></li></ul><p>在 JavaScript 中，this 关键字用于引用当前执行函数的对象。this 的值取决于函数的调用方式。this 可能是任何东西，这取决于它出现在代码中的上下文。</p><h2 id="缓存" tabindex="-1">缓存 <a class="header-anchor" href="#缓存" aria-label="Permalink to &quot;缓存&quot;">​</a></h2><p>强制缓存和协商缓存是 HTTP 缓存机制中的两种不同方式。它们有以下异同点：</p><table><thead><tr><th></th><th>强制缓存</th><th>协商缓存</th></tr></thead><tbody><tr><td>说明</td><td>浏览器在请求资源时，直接从本地缓存中获取，不向服务器发送请求</td><td>浏览器在请求资源时，向服务器发送请求，根据服务器返回的响应头信息来判断是否从本地缓存中获取</td></tr><tr><td>缓存过期时间</td><td>由 Cache-Control 和 Expires 响应头控制</td><td>由 Last-Modified 和 ETag 响应头控制</td></tr><tr><td>缓存命中</td><td>命中缓存时，请求不会发到服务器</td><td>命中缓存时，请求会发到服务器，但服务器会返回 304 Not Modified 状态码，告诉浏览器可以使用本地缓存</td></tr><tr><td>更新缓存</td><td>无法立即更新缓存，除非强制刷新或过期时间到了</td><td>可以通过服务器控制缓存的更新，根据需要返回新的资源或 304 状态码</td></tr></tbody></table><p>需要注意的是，虽然强制缓存和协商缓存是不同的缓存方式，但它们并不互斥。在浏览器缓存机制中，通常会先使用强制缓存，如果缓存过期或者需要强制刷新，再使用协商缓存。</p><h2 id="简单请求和复杂请求" tabindex="-1">简单请求和复杂请求 <a class="header-anchor" href="#简单请求和复杂请求" aria-label="Permalink to &quot;简单请求和复杂请求&quot;">​</a></h2><p>简单请求和复杂请求是指浏览器在<strong>发送跨域请求时</strong>，根据请求的方式、请求头和数据等内容，进行的一种分类。</p><p>简单请求满足以下条件：</p><ol><li>请求方式为 GET、HEAD、POST 中的一种。</li><li>请求头只包含 Content-Type、Accept、Accept-Language、Content-Language、Content-Encoding、Last-Event-ID 中的一种或几种。</li><li>Content-Type 只能是下面三种类型之一： <ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul></li><li>请求中的任意 XMLHttpRequestUpload 对象均没有被使用。</li></ol><blockquote><p>如果请求不满足上述所有条件，则被认为是复杂请求。</p></blockquote><p>复杂请求需要在正式请求前，先发送一个 OPTIONS 请求，称为“预检请求”。预检请求的作用是询问服务器，是否允许跨域请求。如果服务器允许，才会发送正式请求。预检请求中包含了一个 Access-Control-Request-Headers 头部，标明了实际请求中会使用的自定义头部字段。</p><p>在实际请求中，还需要添加一个 Origin 头部，表示请求的源地址。服务器在响应时，需要添加一个 Access-Control-Allow-Origin 头部，表示允许跨域请求的源地址。同时，还需要添加一个 Access-Control-Allow-Credentials 头部，表示允许携带凭证信息（如 Cookie）。</p><p>需要注意的是，跨域请求存在一定的安全风险，因此必须在服务器端进行一定的安全措施，如限制跨域请求的来源、仅允许特定的请求类型等。</p><h2 id="put请求" tabindex="-1">PUT请求 <a class="header-anchor" href="#put请求" aria-label="Permalink to &quot;PUT请求&quot;">​</a></h2><p>PUT 请求方法通常用于更新服务器上的资源。PUT 请求可以覆盖服务器上的指定资源或者创建一个新的资源。PUT 请求的语义是幂等的，即多次请求相同的 URL，返回的结果是一致的，不会对资源造成影响。</p><p>PUT 请求的操作过程如下：</p><ol><li>客户端向服务器发送一个 PUT 请求，请求修改指定的资源。</li><li>服务器返回一个状态码表示请求的成功或失败。</li><li>如果请求成功，服务器将修改后的资源存储在指定位置。</li></ol><p>需要注意的是，PUT 请求通常用于修改整个资源，而不是部分资源。如果需要修改部分资源，可以使用 PATCH 请求。</p><p>此外，PUT 请求还有一些限制。PUT 请求的请求体中应该包含完整的修改后的资源，因此客户端必须知道修改后的资源是什么。如果客户端不知道修改后的资源是什么，就应该使用 POST 请求。另外，PUT 请求通常需要进行身份验证，以确保只有授权用户才能修改资源。</p>',44),p=[d];function h(n,s,c,u,_,m){return a(),e("div",null,p)}const T=t(o,[["render",h]]);export{b as __pageData,T as default};
