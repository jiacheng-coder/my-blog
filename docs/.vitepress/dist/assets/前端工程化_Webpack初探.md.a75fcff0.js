import{_ as e,o as a,c as n,U as t}from"./chunks/framework.a7041386.js";const g=JSON.parse('{"title":"Webpack 初探","description":"","frontmatter":{"tag":["前端工程化"]},"headers":[],"relativePath":"前端工程化/Webpack初探.md","filePath":"前端工程化/Webpack初探.md","lastUpdated":1690701222000}'),r={name:"前端工程化/Webpack初探.md"},s=t('<h1 id="webpack-初探" tabindex="-1">Webpack 初探 <a class="header-anchor" href="#webpack-初探" aria-label="Permalink to &quot;Webpack 初探&quot;">​</a></h1><h2 id="核心概念" tabindex="-1">核心概念 <a class="header-anchor" href="#核心概念" aria-label="Permalink to &quot;核心概念&quot;">​</a></h2><h3 id="entry-入口" tabindex="-1">Entry：入口 <a class="header-anchor" href="#entry-入口" aria-label="Permalink to &quot;Entry：入口&quot;">​</a></h3><p><strong>Entry</strong> 指示 webpack 应该使用哪个模块，来作为构建其内部 <a href="https://webpack.docschina.org/concepts/dependency-graph/" target="_blank" rel="noreferrer">依赖图(dependency graph)</a> 的开始</p><p>`/** @type {import(&#39;webpack&#39;).Configuration} */</p><p>module.exports = { mode: &#39;development&#39;, entry: { main: { // 配置 chunk 名 filename: &#39;target_index.js&#39;, // 输出filename名 import: &#39;./src/index.js&#39;, // 指定入口文件 runtime: &#39;runTimeOne&#39;, // 配置当前chunk的运行时环境，默认情况下不同chunk的缓存是隔离开的 }, test: { filename: &#39;target_b.js&#39;, import: &#39;./src/b.js&#39;, // runtime: &#39;runTimeOne&#39;, // 和 main chunk 共享一个运行时环境 dependOn: &#39;main&#39;, // 指定要共享的运行时环境所在的chunk名，如果没有会报错 } }, output: { clean: true // 每次构建前清空输出文件夹下的内容 }, }`</p><h3 id="output-出口" tabindex="-1">Output：出口 <a class="header-anchor" href="#output-出口" aria-label="Permalink to &quot;Output：出口&quot;">​</a></h3><p><strong>output</strong> 属性告诉 webpack 在哪里输出它所创建的 <em>bundle</em>，以及如何命名这些文件。主要输出文件的默认值是 ./dist/main.js，其他生成文件默认放置在 ./dist 文件夹中。</p><p>为啥要有hash?？【出于复用缓存的考虑】</p><p>浏览器有一个缓存机制-—-＞如果浏览器刷新时请求的当前js的文件名没有产生变化，则浏览器不会请求该资源而是直接使用缓存</p><p>有一个插件 plugins 是用来帮我们组装 index.html 页面的，配置hash是为了让我们的文件变化能够实时的被浏览器感知到</p><p>`/** @type {import(&#39;webpack&#39;).Configuration} */</p><p>module.exports = { entry: { index: &#39;./src/index.js&#39;, search: &#39;./src/search.js&#39;, }, output: { filename: &#39;[name].[contenthash:6].js&#39;, // [name]模板字符串 path: __dirname + &#39;/dist&#39;, clean: true }, };`</p><h3 id="loader-代码转换" tabindex="-1">Loader：代码转换 <a class="header-anchor" href="#loader-代码转换" aria-label="Permalink to &quot;Loader：代码转换&quot;">​</a></h3><p>webpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。<strong>loader</strong> 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 <a href="https://webpack.docschina.org/concepts/modules" target="_blank" rel="noreferrer">模块</a>，以供应用程序使用，以及被添加到依赖图中。</p><p>使用 loader 可以把 css 之类的</p><p>loader 帮 webpack 做了一部分的代码转换工作</p><p>之前我们在用脚手架vue-cli, create-react-app的时候不需要关注这些东西是因为这些脚手架在底层帮我们都将webpack配置好了</p><h4 id="css-loader-模块化" tabindex="-1">css-loader 模块化 <a class="header-anchor" href="#css-loader-模块化" aria-label="Permalink to &quot;css-loader 模块化&quot;">​</a></h4><p>webpack.config.js</p><p>`/** @type {import(&#39;webpack&#39;).Configuration} */</p><p>const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);</p><p>module.exports = { mode: &quot;development&quot;, entry: { index: &quot;./src/index.js&quot;, search: &quot;./src/search.js&quot;, }, output: { filename: &quot;[name].[contenthash:6].js&quot;, // [name]模板字符串 path: <strong>dirname + &quot;/dist&quot;, clean: true, }, plugins: [ // 添加插件实例 new MiniCssExtractPlugin({ filename: &#39;[name].[contenthash].css&#39;, }), ], module: { rules: [ { test: /.css$/i, use: [ MiniCssExtractPlugin.loader, { loader: &#39;css-loader&#39;, options: { modules: { localIdentName: &#39;[path][name]</strong>[local]--[hash:base64:5]&#39;, }, }, }, ], }, ], }, };`</p><p>App.js</p><p>`import appStyle from &#39;./App.css&#39;</p><p>function App() { const element = document.createElement(&#39;div&#39;) element.innerHTML = &#39;This is App&#39; element.className = appStyle.wrapper return element } document.body.appendChild(App())`</p><p>Header.js</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">import headerStyle from &#39;./Header.css&#39; function Header() {   const element = document.createElement(&#39;div&#39;)   element.innerHTML = &#39;This is Header&#39;   element.className = headerStyle.wrapper   return element } document.body.appendChild(Header())</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="plugin-插件机制" tabindex="-1">Plugin：插件机制 <a class="header-anchor" href="#plugin-插件机制" aria-label="Permalink to &quot;Plugin：插件机制&quot;">​</a></h3><p>loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。</p><h4 id="和-loader-的比较" tabindex="-1">和 loader 的比较 <a class="header-anchor" href="#和-loader-的比较" aria-label="Permalink to &quot;和 loader 的比较&quot;">​</a></h4><p>webpack 的 loader 和 plugin 都是用于扩展 webpack 功能的工具，但它们在使用方式和处理过程中有一些区别。</p><p><strong>Loader（加载器）【模块转换阶段】</strong></p><ol><li>loader 主要用于<strong>对模块源代码进行转换</strong>。它们在构建过程中将文件从输入（例如 .css、.scss、.jsx 等）转换为输出（通常是 JavaScript 模块）。</li><li>loader 是在 module.rules 配置中定义的，并且可以链式调用。链中的每个 loader 都会对资源进行转换，然后将结果传递给下一个 loader。</li><li>loader 可以同步或异步执行，但通常是同步的。</li></ol><p><strong>Plugin（插件）【不仅仅是模块转换阶段】</strong></p><ol><li>plugin 是用于执行<strong>更广泛</strong>的任务，如<strong>优化、代码分割、资源管理</strong>等。它们可以在整个<strong>构建过程中的不同阶段</strong>执行操作，而<strong>不仅仅是在模块转换阶段</strong>。</li><li>plugin 是在 plugins 配置中定义的，通过实例化插件并将其添加到 plugins 数组中来使用。</li><li>plugin 通过订阅 webpack 的事件钩子（hooks）来工作，这使得它们可以在构建过程的特定时刻执行操作。</li></ol><p><strong>区别和联系</strong></p><ol><li>区别：loader 主要用于转换模块源代码，而 plugin 用于执行更广泛的任务。loader 在 module.rules 中定义，plugin 在 plugins 中定义。</li><li>联系：loader 和 plugin 都是用于扩展 webpack 功能的工具，它们可以相互配合使用。例如，css-loader 和 style-loader 可以将 CSS 转换为 JavaScript 模块，然后 MiniCssExtractPlugin 插件可以将这些模块提取到单独的 CSS 文件中。</li></ol><p>总之，loader 和 plugin 是 webpack 的两种扩展方式，它们在不同的场景和处理过程中发挥作用，但都是为了实现更丰富的构建功能。</p><h2 id="深入devdepend-dependencies" tabindex="-1">深入devDepend &amp;&amp; dependencies <a class="header-anchor" href="#深入devdepend-dependencies" aria-label="Permalink to &quot;深入devDepend &amp;&amp; dependencies&quot;">​</a></h2><h3 id="iife【立即执行函数】" tabindex="-1">IIFE【立即执行函数】 <a class="header-anchor" href="#iife【立即执行函数】" aria-label="Permalink to &quot;IIFE【立即执行函数】&quot;">​</a></h3><p>只要加上运算符就能够进行隐式转换，将函数转换成函数表达式，成为立即执行函数</p><p>当一个函数变成函数表达式以后 丢掉自己原来的名字</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">+function () { 	console.log(&#39;12&#39;) }()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="正文" tabindex="-1">正文 <a class="header-anchor" href="#正文" aria-label="Permalink to &quot;正文&quot;">​</a></h3><p>只要不发包，这二者就随便放，大多数情况下确实如此。【合法但不合理】</p><p>我们还需要考虑SSR 服务端渲染【服务端渲染必须要时刻关注package. json即使你不发包】</p><p>很多人他会觉得如果将dependencies里的东西移到devDependencies里去会造成性能问题 除非是ssr才会造成这种情况</p><p>你在生产会用的依赖 比如react Lodash 你全部放到dependencies里去</p><p>在生产不会用到的依赖，比如ts webpack</p><p>构建生产代码 全部放到devDependencies里去</p><p>这是国内约定俗成的用法</p><p>这样的话你在ssr里也不会出错即使你会多安装一些依赖在ssr中【ssr里是会用到package.json在服务端装依赖的】，但是也比出错要好</p><p>在常规客户端渲染的情况下，二者无差异</p><p>package.json不会参与到webpack的构建工作中</p>',55),p=[s];function o(l,i,d,c,u,h){return a(),n("div",null,p)}const b=e(r,[["render",o]]);export{g as __pageData,b as default};
