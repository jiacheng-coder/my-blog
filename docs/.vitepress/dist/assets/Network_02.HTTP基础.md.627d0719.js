import{_ as t,o as l,c as e,U as i}from"./chunks/framework.876add27.js";const o="/assets/image-20230306182216376.f51af629.png",a="/assets/image-20230306191130659.fb7b6a65.png",r="/assets/image-20230306191322311.28b7d59e.png",T="/assets/image-20230306191829322.82ed4b4c.png",n="/assets/image-20230306211035355.f69bba94.png",s="/assets/image-20230306211524458.31b2f8b9.png",p="/assets/image-20230306211643270.7e89506b.png",P="/assets/image-20230306212023782.64829b72.png",g="/assets/image-20230306212138783.0b21b453.png",d="/assets/image-20230306212450385.73a8bd5a.png",k=JSON.parse('{"title":"HTTP基础","description":"","frontmatter":{"tag":["计算机网络"]},"headers":[],"relativePath":"Network/02.HTTP基础.md","filePath":"Network/02.HTTP基础.md","lastUpdated":1689602218000}'),c={name:"Network/02.HTTP基础.md"},h=i('<h1 id="http基础" tabindex="-1">HTTP基础 <a class="header-anchor" href="#http基础" aria-label="Permalink to &quot;HTTP基础&quot;">​</a></h1><h2 id="http基本概念" tabindex="-1">HTTP基本概念 <a class="header-anchor" href="#http基本概念" aria-label="Permalink to &quot;HTTP基本概念&quot;">​</a></h2><h3 id="http是什么" tabindex="-1">HTTP是什么? <a class="header-anchor" href="#http是什么" aria-label="Permalink to &quot;HTTP是什么?&quot;">​</a></h3><p>HTTP是<strong>基于TCP协议</strong>的<strong>应用层</strong>传输协议, 由请求和响应构成, 是一个标准的客户端服务器模型</p><blockquote><p><strong>注意</strong>：客户端与服务器的角色不是固定的，一端充当客户端，也可能在某次请求中充当服务器。这取决与请求的发起端。HTTP协议属于应用层，建立在传输层协议TCP之上。客户端通过与服务器建立TCP连接，之后发送HTTP请求与接收HTTP响应都是通过访问Socket接口来调用TCP协议实现。</p></blockquote><p><code>HTTP</code> 是一种<strong>无状态</strong> (stateless) 协议, <code>HTTP</code>协议本身不会对发送过的请求和相应的通信状态进行持久化处理。这样做的目的是为了保持HTTP协议的简单性，从而能够快速处理大量的事务, 提高效率。</p><p>然而，在许多应用场景中，我们需要保持用户登录的状态或记录用户购物车中的商品。由于<code>HTTP</code>是无状态协议，所以必须引入一些技术来记录管理状态，例如<code>Cookie</code>。</p><p>HTTP是一个在「两点」之间传输超文本数据的「约定和规范」</p><ul><li>基于TCP传输层协议</li><li>是应用层传输协议</li><li>是无状态协议, 通过类似Cookie的技术记录和管理状态</li><li>用来在两点之间传输超文本(<strong>文字、图片、音频、视频等</strong>)数据</li></ul><h3 id="常见状态码" tabindex="-1">常见状态码 <a class="header-anchor" href="#常见状态码" aria-label="Permalink to &quot;常见状态码&quot;">​</a></h3><ul><li><p>1xx: 目前是协议处理的中间状态, 需要后续操作</p><ul><li>「协议切换」HTTP协议切换为WebSocket协议</li></ul></li><li><p>2xx: 成功, 报文已收到并被正确处理</p><ul><li>「200 OK」响应头有body数据(对于非HEAD请求)</li><li>「202 Accepted」接受请求</li><li>「204 NoCotent」响应头没有body数据</li><li>「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul></li><li><p>3xx: 重定向</p><ul><li>301: 永久重定向</li><li>302: 临时重定向</li><li>304: 缓存重定向, 告诉客户端可以继续使用缓存资源，用于缓存控制。</li></ul></li><li><p>4xx: 客户端错误</p><ul><li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul></li><li><p>5xx: 服务端错误</p><ul><li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li></ul></li></ul><h3 id="http常见字段" tabindex="-1">HTTP常见字段 <a class="header-anchor" href="#http常见字段" aria-label="Permalink to &quot;HTTP常见字段&quot;">​</a></h3><ul><li>Host: 指定服务器域名</li><li>Content- Length: 表示本次回应的数据长度 <ul><li>大家应该都知道 HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP 传输协议，就会存在一个“粘包”的问题，<strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题</strong>。具体什么是 TCP 粘包，可以看这篇文章：<a href="https://xiaolincoding.com/network/3_tcp/tcp_stream.html" target="_blank" rel="noreferrer">如何理解是 TCP 面向字节流协议？</a></li></ul></li><li>Connection字段: <ul><li>「Connection: Keep-Alive」客户端要求服务器使用「HTTP长链接」机制, 以便于其他请求复用</li></ul></li><li>Content-Type字段 <ul><li>用于服务器回应时,告诉客户端本次数据的格式</li><li>和请求头的「Accept」相对应</li></ul></li><li>Content- Encoding字段 <ul><li>说明数据的压缩方法</li><li>与客户端在请求时的 「Accept-Encoding」 字段对应</li></ul></li></ul><h2 id="http方法" tabindex="-1">HTTP方法 <a class="header-anchor" href="#http方法" aria-label="Permalink to &quot;HTTP方法&quot;">​</a></h2><table><thead><tr><th style="text-align:center;">方法</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">GET</td><td style="text-align:center;">请求</td></tr><tr><td style="text-align:center;">HEAD</td><td style="text-align:center;">请求文档的首部</td></tr><tr><td style="text-align:center;">POST</td><td style="text-align:center;">向服务器发送数据</td></tr><tr><td style="text-align:center;">PUT</td><td style="text-align:center;">在指明的URL下存储一个文档</td></tr><tr><td style="text-align:center;">DELETE</td><td style="text-align:center;">删除URL标志的文档</td></tr><tr><td style="text-align:center;">CONNECT</td><td style="text-align:center;">用于代理服务器</td></tr><tr><td style="text-align:center;">OPTIONS</td><td style="text-align:center;">请求一些选项信息</td></tr><tr><td style="text-align:center;">TRACE</td><td style="text-align:center;">用来进行环回测试</td></tr><tr><td style="text-align:center;">PATCH</td><td style="text-align:center;">对PUT方法的补充，用来对已知资源进行局部更新</td></tr></tbody></table><h2 id="get和post是否安全和幂等" tabindex="-1">GET和POST是否安全和幂等 <a class="header-anchor" href="#get和post是否安全和幂等" aria-label="Permalink to &quot;GET和POST是否安全和幂等&quot;">​</a></h2><p>先说明下安全和幂等的概念：</p><ul><li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li><li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li></ul><p>如果从 RFC 规范定义的语义来看：</p><ul><li><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</li><li><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</li></ul><p>小结:</p><p>GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。</p><p>POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。</p><blockquote><p>但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：</p><ul><li><p>可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等。</p></li><li><p>可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等。</p></li></ul></blockquote><p>再引申一下「安全」的概念:</p><p>如果「安全」放入概念是指信息是否会被泄漏的话，虽然 POST 用 body 传输数据，而 GET 用 URL 传输，这样数据会在浏览器地址拦容易看到，但是并不能说 GET 不如 POST 安全的。</p><p>因为 HTTP 传输的内容都是明文的，虽然在浏览器地址拦看不到 POST 提交的 body 数据，但是只要抓个包就都能看到了。</p><p>所以，要避免传输过程中数据被窃取，就要使用 HTTPS 协议，这样所有 HTTP 的数据都会被加密传输。</p><h2 id="http缓存技术" tabindex="-1">HTTP缓存技术 <a class="header-anchor" href="#http缓存技术" aria-label="Permalink to &quot;HTTP缓存技术&quot;">​</a></h2><h3 id="实现方式" tabindex="-1">实现方式 <a class="header-anchor" href="#实现方式" aria-label="Permalink to &quot;实现方式&quot;">​</a></h3><p>对于一些重复性的HTTP请求, 可以把这对的数据都缓存在本地, 下次直接读取本地数据即可, 从而避免了发送HTTP请求, 提升了性能</p><p>有两种实现方式:</p><ul><li>强制缓存</li><li>协商缓存</li></ul><h2 id="强制缓存" tabindex="-1">强制缓存 <a class="header-anchor" href="#强制缓存" aria-label="Permalink to &quot;强制缓存&quot;">​</a></h2><p>强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的<strong>主动性在于浏览器这边</strong>。</p><p>强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：</p><ul><li><code>Cache-Control</code>， 是一个相对时间；(优先级高于Expires)</li><li><code>Expires</code>，是一个绝对时间；</li></ul><p><strong>Cache-control</strong> 选项更多一些，设置更加精细，所以<strong>建议使用 Cache-Control 来实现强缓存</strong>。具体的实现流程如下：</p><ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li><li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li><li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li></ul><h3 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;协商缓存&quot;">​</a></h3><p>当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 <code>304</code>，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存</p><blockquote><p>协商缓存需要在强制缓存的基础上使用</p></blockquote><p><img src="'+o+'" alt="image-20230306182216376"></p><p>上图就是一个协商缓存的过程，所以<strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong>。</p><p>协商缓存可以基于两种头部来实现。</p><p>第一种：请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现，这两个字段的意思是：</p><ul><li>响应头部中的 <code>Last-Modified</code>：标示这个响应资源的最后修改时间；</li><li>请求头部中的 <code>If-Modified-Since</code>：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li></ul><p>第二种：请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段，这两个字段的意思是：</p><ul><li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li><li>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li></ul><blockquote><p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的</p><p>相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</p></blockquote><p>**为什么 ETag 的优先级更高？**这是因为 ETag 主要能解决 Last-Modified 几个比较难以解决的问题：</p><ol><li>在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；</li><li>可能有些文件是在秒级以内修改的，<code>If-Modified-Since</code> 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；</li><li>有些服务器不能精确获取文件的最后修改时间。</li></ol><p>注意，<strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p><p>当使用 ETag 字段实现的协商缓存的过程：</p><ul><li><p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</p></li><li><p>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：</p><ul><li>如果没有过期，则直接使用本地缓存；</li><li>如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；</li></ul></li><li><p>服务器再次收到请求后，</p><p>会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较</p><ul><li><strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；</li><li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li></ul></li><li><p>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</p></li></ul><h2 id="http特性" tabindex="-1">HTTP特性 <a class="header-anchor" href="#http特性" aria-label="Permalink to &quot;HTTP特性&quot;">​</a></h2><h3 id="http-1-1-优点" tabindex="-1">HTTP/1.1 优点 <a class="header-anchor" href="#http-1-1-优点" aria-label="Permalink to &quot;HTTP/1.1 优点&quot;">​</a></h3><ul><li>简单</li><li>易于拓展 <ul><li>HTTP是工作在应用层(OSI第七层)的协议, 它的下层可以随意变化, 例如 <ul><li>HTTPS就是在HTTP与TCP层之间添加了SSL/TLS安全传输层</li><li>HTTP/1.1 和 HTTP/2.0 传输协议使用的是 TCP 协议，而到了 HTTP/3.0 传输协议改用了 UDP 协议</li></ul></li></ul></li><li>应用广泛, 天然的跨平台优越性</li></ul><h3 id="http-1-1-缺点" tabindex="-1">HTTP/1.1 缺点 <a class="header-anchor" href="#http-1-1-缺点" aria-label="Permalink to &quot;HTTP/1.1 缺点&quot;">​</a></h3><p>HTTP协议有两把「双刃剑」:「无状态」「明文传输」「不安全」</p><ul><li>「无状态」 <ul><li>不需要额外资源来记录状态, 减轻服务器负担</li><li>很难完成具有关联性的操作</li><li>解决方案: Cookie技术, 即客户端第一次请求后, 服务器额外返回一个带有客户端信息的「小贴纸」,客户端第二次请求时就会带上这个「小贴纸」,服务器就认得了</li></ul></li><li>明文传输 <ul><li>抓包后的数据便于阅读, 没有隐私</li></ul></li><li>不安全 <ul><li>使用明文通信, 内容会被窃听</li><li>不验证通信方的身份, 有可能被伪装</li><li>无法证明报文的完整性，所以有可能已遭篡改</li></ul></li></ul><blockquote><p>HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 安全传输层，使得在安全上达到了极致。</p></blockquote><h3 id="http性能" tabindex="-1">HTTP性能 <a class="header-anchor" href="#http性能" aria-label="Permalink to &quot;HTTP性能&quot;">​</a></h3><p>HTTP 协议是基于 <strong>TCP/IP</strong>，并且使用了「<strong>请求 - 应答</strong>」的通信模式，所以性能的关键就在这<strong>两点</strong>里。</p><ul><li>长连接 <ul><li>不需要每发起一个请求，都要新建一次 TCP 连接（三次握手），减轻了服务器端的负载</li><li>只要任意一端没有明确提出断开连接，则保持 TCP 连接状态</li></ul></li><li>队头阻塞 <ul><li>HTTP基于「请求-应答」的模式, 当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「<strong>队头阻塞</strong>」，好比上班的路上塞车。</li></ul></li><li>管道网络传输(非默认开启) <ul><li>解决了<strong>请求</strong>的队头阻塞 <ul><li>在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间。</strong></li></ul></li><li>无法解决<strong>响应</strong>的队头阻塞: <ul><li><strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>。如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」</li></ul></li><li>实际上 HTTP/1.1 管道化技术不是默认开启，而且浏览器基本都没有支持</li></ul></li></ul><blockquote><p>总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能</p></blockquote><h2 id="http-与-https" tabindex="-1">HTTP 与 HTTPS <a class="header-anchor" href="#http-与-https" aria-label="Permalink to &quot;HTTP 与 HTTPS&quot;">​</a></h2><h3 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h3><ul><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li><li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul><h3 id="解决了http的哪些问题" tabindex="-1">解决了HTTP的哪些问题 <a class="header-anchor" href="#解决了http的哪些问题" aria-label="Permalink to &quot;解决了HTTP的哪些问题&quot;">​</a></h3><p>HTTP明文传输,安全上存在如下风险:</p><ul><li>窃听风险</li><li>篡改风险</li><li>冒充风险</li></ul><p>HTTPS 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议，可以很好的解决了上述的风险：</p><ul><li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li><li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li><li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li></ul><p>HTTPS是如何解决风险的呢:</p><ul><li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li><li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险; 数字签名保证消息的来源可靠性(确认消息是由持有私钥的一方发送的)</li><li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li></ul><h4 id="混合加密" tabindex="-1">混合加密 <a class="header-anchor" href="#混合加密" aria-label="Permalink to &quot;混合加密&quot;">​</a></h4><ul><li>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式 <ul><li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密</li><li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据</li></ul></li><li>采用混合加密的原因 <ul><li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li><li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li></ul></li></ul><h4 id="摘要算法-数字签名" tabindex="-1">摘要算法 + 数字签名 <a class="header-anchor" href="#摘要算法-数字签名" aria-label="Permalink to &quot;摘要算法 + 数字签名&quot;">​</a></h4><p>在计算机里会<strong>用摘要算法（哈希函数）来计算出内容的哈希值</strong>，也就是内容的「指纹」，这个<strong>哈希值是唯一的，且无法通过哈希值推导出内容</strong>。</p><p>通过哈希算法可以确保内容不会被篡改，<strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。</p><p><img src="'+a+'" alt="image-20230306191130659"></p><blockquote><p>此时需要引入数字签名的概念, 在此之前要先理解一下非对称加密算法</p></blockquote><p>计算机里会用<strong>非对称加密算法</strong>来解决，共有两个密钥：</p><ul><li>一个是公钥，这个是可以公开给所有人的；</li><li>一个是私钥，这个必须由本人管理，不可泄露。</li></ul><p>这两个密钥可以<strong>双向加解密</strong>的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。</p><p>流程的不同，意味着目的也不相同：</p><ul><li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li><li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li></ul><p>一般我们不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。</p><p>所以非对称加密的用途主要在于<strong>通过「私钥加密，公钥解密」的方式，来确认消息的身份</strong>，我们常说的<strong>数字签名算法</strong>，就是用的是这种方式，不过私钥加密内容不是内容本身，而是<strong>对内容的哈希值加密</strong>。</p><p><img src="'+r+'" alt="image-20230306191322311"></p><p>一个例子可以很好的帮助理解:</p><p>你想向老师请假，一般来说是要求由家长写一份请假理由并签名，老师才能允许你请假。</p><p>但是你有模仿你爸爸字迹的能力，你用你爸爸的字迹写了一份请假理由然后签上你爸爸的名字，老师一看到这个请假条，查看字迹和签名，就误以为是你爸爸写的，就会允许你请假。</p><p>那作为老师，要如何避免这种情况发生呢？现实生活中的，可以通过电话或视频来确认是否是由父母发出的请假，但是计算机里可没有这种操作。</p><p>私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。</p><p>引入了数字签名算法后，你就无法模仿你爸爸的字迹来请假了，你爸爸手上持有着私钥(相当于服务端)，你老师持有着公钥(相当于客户端)。</p><p>这样只有用你爸爸手上的私钥才对请假条进行「签名」，老师通过公钥看能不能解出这个「签名」，如果能解出并且确认内容的完整性，就能证明是由你爸爸发起的请假条，这样老师才允许你请假，否则老师就不认。</p><h4 id="数字证书-ca" tabindex="-1">数字证书(CA) <a class="header-anchor" href="#数字证书-ca" aria-label="Permalink to &quot;数字证书(CA)&quot;">​</a></h4><p><img src="'+T+'" alt="image-20230306191829322"></p><h3 id="https一定安全可靠嘛" tabindex="-1">HTTPS一定安全可靠嘛? <a class="header-anchor" href="#https一定安全可靠嘛" aria-label="Permalink to &quot;HTTPS一定安全可靠嘛?&quot;">​</a></h3><p>这个问题的场景是这样的：客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手</p><p>但是要发生这种场景是有前提的，前提是用户点击接受了中间人服务器的证书。</p><p>中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。</p><p><img src="'+n+'" alt="image-20230306211035355"></p><p>如果用户执意点击「继续浏览此网站」，相当于用户接受了中间人伪造的证书，那么后续整个 HTTPS 通信都能被中间人监听了。</p><p>另外，如果你的电脑中毒了，被恶意导入了中间人的根证书，那么在验证中间人的证书的时候，由于你操作系统信任了中间人的根证书，那么等同于中间人的证书是合法的，这种情况下，浏览器是不会弹出证书存在问题的风险提醒的。</p><p>这其实也不关 HTTPS 的事情，是你电脑中毒了才导致 HTTPS 数据被中间人劫持的。</p><p>所以，<strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全</strong>。</p><blockquote><p>如何避免中间人攻击? - 通过HTTPS双向认证</p></blockquote><p>一般我们的 HTTPS 是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。</p><p>如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。</p><h2 id="http演变" tabindex="-1">HTTP演变 <a class="header-anchor" href="#http演变" aria-label="Permalink to &quot;HTTP演变&quot;">​</a></h2><h3 id="http-1-1相比-http-1-0-提高了什么性能" tabindex="-1">HTTP/1.1相比 HTTP/1.0 提高了什么性能？ <a class="header-anchor" href="#http-1-1相比-http-1-0-提高了什么性能" aria-label="Permalink to &quot;HTTP/1.1相比 HTTP/1.0 提高了什么性能？&quot;">​</a></h3><p>HTTP/1.1 相比 HTTP/1.0 性能上的改进：</p><ul><li>使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。</li><li>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul><p>HTTP/1.1 还是有性能瓶颈：</p><ul><li>请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</li><li>每次互相发送相同的首部造成的浪费较多；</li><li>服务器端有可能产生「队头阻塞」</li><li>没有请求优先级控制</li><li>请求只能从客户端开始, 服务器只能被动响应</li></ul><h3 id="http-2的优化" tabindex="-1">HTTP/2的优化 <a class="header-anchor" href="#http-2的优化" aria-label="Permalink to &quot;HTTP/2的优化&quot;">​</a></h3><p>HTTP/2 协议是基于 HTTPS 的，这保证了 HTTP/2 的安全性</p><p><img src="'+s+'" alt="image-20230306211524458"></p><p>那 HTTP/2 相比 HTTP/1.1 性能上的改进：</p><ul><li>头部压缩</li><li>二进制格式</li><li>并发传输</li><li>服务器主动推送资源</li></ul><p><em>1. 头部压缩</em></p><p>HTTP/2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</p><p>这就是所谓的 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</p><p><em>2. 二进制格式</em></p><p>HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。</p><p><img src="'+p+'" alt="image-20230306211643270"></p><p>收到报文后, 无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</p><p><em>3. 并发传输</em></p><p>我们都知道 HTTP/1.1 的实现是基于请求-响应模型的。同一个连接中，HTTP 完成一个事务（请求与响应），才能处理下一个事务，也就是说在发出请求等待响应的过程中，是没办法做其他事情的，如果响应迟迟不来，那么后续的请求是无法发送的，也造成了<strong>队头阻塞</strong>的问题。</p><p>而 HTTP/2 就很牛逼了，引出了 Stream 概念，多个 Stream 复用在一条 TCP 连接。</p><p>比如下图，服务端<strong>并行交错地</strong>发送了两个响应： Stream 1 和 Stream 3，这两个 Stream 都是跑在一个 TCP 连接上，客户端收到后，会根据相同的 Stream ID 有序组装成 HTTP 消息。</p><p><img src="'+P+'" alt="image-20230306212023782"></p><p><em>4、服务器推送</em></p><p>HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以<strong>主动</strong>向客户端发送消息。</p><p>客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p><p>再比如，客户端通过 HTTP/1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求，需要两次消息往返，如下图左边部分：</p><p><img src="'+g+'" alt="image-20230306212138783"></p><p>​ 如上图右边部分，在 HTTP/2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数。</p><blockquote><p>HTTP/2 有什么缺陷？</p></blockquote><p>​ HTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，看似很完美了，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。</p><p>​ <strong>HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。</strong></p><p>​ 例如发送方发送了很多个 packet，每个 packet 都有自己的序号，你可以认为是 TCP 的序列号，其中 packet 3 在网络中丢失了，即使 packet 4-6 被接收方收到后，由于内核中的 TCP 数据不是连续的，于是接收方的应用层就无法从内核中读取到，只有等到 packet 3 重传后，接收方的应用层才可以从内核中读取到数据，这就是 HTTP/2 的队头阻塞问题，是在 TCP 层面发生的。</p><p>​ 所以，一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</p><h3 id="http-3的优化" tabindex="-1">HTTP/3的优化 <a class="header-anchor" href="#http-3的优化" aria-label="Permalink to &quot;HTTP/3的优化&quot;">​</a></h3><p>前面我们知道了 HTTP/1.1 和 HTTP/2 都有队头阻塞的问题：</p><ul><li>HTTP/1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是<strong>没有解决响应的队头阻塞</strong>，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。</li><li>HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong>，这属于 TCP 层队头阻塞。</li></ul><p>HTTP/2 队头阻塞的问题是因为 TCP，所以 <strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p><p><img src="'+d+'" alt="image-20230306212450385"></p><p>UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p><p>QUIC 有以下 3 个特点。</p><ul><li><p>无队头阻塞</p><ul><li>QUIC也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</li><li>QUIC 有自己的一套机制可以保证传输的可靠性的。<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。</li></ul></li><li><p>更快的连接建立</p><ul><li>HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是 <strong>QUIC 内部包含了 TLS</strong></li><li>它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS/1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商</li></ul></li><li><p>连接迁移</p><ul><li><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。</p></li><li><p>那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p></li></ul></li></ul>',154),u=[h];function H(m,b,S,C,q,x){return l(),e("div",null,u)}const _=t(c,[["render",H]]);export{k as __pageData,_ as default};
